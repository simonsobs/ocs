#!/usr/bin/env python3

try:
    # wampy (0.9.20) requires this gevent patch, but a warning is
    # issued because the patch occurs too late.  So this avoids the
    # warning, and maybe makes the patch work better?
    import gevent.monkey
    gevent.monkey.patch_all()
except ImportError:
    pass

import sys

import ocs
from ocs import client_wampy as cw
from ocs import ocsbow

parser = ocsbow.get_parser()


args = parser.parse_args()
ocs.site_config.reparse_args(args, '*host*')

if args.command == 'config':
    print('ocs configuration summary')
    print('-------------------------')
    print()
    print('ocs import led to: %s' % (ocs.__file__))
    print()
    site, _, _ = ocs.site_config.get_config(args, '*host*')
    print('Site file was determined to be: %s' % site.source_file)
    print()
    print('The site file describes %i hosts:' % len(site.hosts))
    for k,v in site.hosts.items():
        print('  Host %s includes %i agent instances:' % (k, len(v.instances)))
        for inst in v.instances:
            print('    %s::%s' % (inst['agent-class'], inst['instance-id']))
        print()

if args.command == 'plugins':
    print('ocs plugin detection')
    print('--------------------')
    print('Scanning.')
    site, host, _  = ocs.site_config.get_config(args, '*host*')
    for p in host.agent_paths:
        print('  ... adding to path: %s' % p)
        sys.path.append(p)
    ocs.site_config.scan_for_agents()
    print('Found:')
    for k,v in ocs.site_config.agent_script_reg.items():
        print('  %-20s : %s' % (k,v))
    print()

elif args.command in ['launch']:
    # This is specifically for starting the host master agent process;
    # that's different than starting the host master's main process
    # (see start/stop for that).

    # Parse the config to find this host's HostMaster instance info.
    site, host, instance = ocs.site_config.get_config(args, 'HostMaster')

    # Most important is the site filename and host alias.
    import os
    hm_script = os.path.join(host.agent_paths[0], 'host_master/host_master.py')
    cmd = [sys.executable, hm_script,
           '--site-file', site.source_file,
           '--site-host', host.name]
    print('Launching host_master (%s)...' % cmd[1])
    pid = os.spawnv(os.P_NOWAIT, cmd[0], cmd)
    print('... pid is %i' % pid)

elif args.command in ['status', 'start', 'stop', 'monitor']:

    def decode_exception(args):
        """
        Decode certain RuntimeError raised by wampy.
        """
        try:
            text, data = args[0][4:6]
            assert(text.startswith('wamp.'))
        except Exception as e:
            return False, args, str(args)
        return True, text, str(data)

    # Parse the config to find this host's HostMaster instance info.
    site, host, instance = ocs.site_config.get_config(args, 'HostMaster')

    # Connect to crossbar.
    master_addr = '%s.%s' % (site.hub.data['address_root'], instance.data['instance-id'])
    
    if args.command == 'monitor' or args.follow:
        feed_addr = master_addr + '.feed'
        class NosyClient(cw.ControlClient):
            @cw.subscribe(topic=feed_addr)
            def watch_events(self, *args, **kw):
                print('FEED:', args, kw)
            @cw.subscribe(topic='observatory.registry.feeds.agent_activity')
            def watch_events(self, *args, **kw):
                print('A2:', args, kw)
        client_class = NosyClient
    else:
        client_class = cw.ControlClient

    client = client_class(
        master_addr,
        url=site.hub.data['wamp_server'],
        realm=site.hub.data['wamp_realm'])
    try:
        client.start()
    except ConnectionRefusedError as e:
        print('Failed to establish connection to crossbar server.')
        print('  url: %s' % site.hub.data['wamp_server'])
        print('  realm: %s' % site.hub.data['wamp_realm'])
        sys.exit(1)

    try:
        if args.command == 'status':
            stat = client.request('status', 'master', [])
        elif args.command == 'start':
            stat = client.request('start', 'master', [])
        elif args.command == 'stop':
            stat = client.request('stop', 'master', [])
        else:
            stat = None

        if stat is not None:
            # Decode stat
            err, msg, session = stat
            if err != ocs.OK:
                print('Error when requesting master Process "%s":\n  %s' %
                      (args.command, msg))
            print('Status of the master Process: %s' % session['status'])

        if args.command == 'stop' and err == ocs.OK:
            # Block for it to exit.
            print('Waiting for exit...')
            stat = client.request('wait', 'master', timeout=5)
            err, msg, session = stat
            if err == ocs.TIMEOUT:
                print(" ... timed-out!  Last status report is: %s" % session['status'])
            elif err == ocs.OK:
                print(" ... done.")
            else:
                print(" ... Error! : %s" % msg)

        elif args.command == 'monitor' or args.follow:
            import time
            session = None
            try:
                while True:
                    print('[Blocking for logs; Ctrl-C to exit.]')
                    time.sleep(10)
            except KeyboardInterrupt:
                pass
        
        if session is not None:
            n_trunc = 20
            print('Most recent session log (truncated to %i lines):' % n_trunc)
            for msg in session.get('messages',[])[-n_trunc:]:
                print('  %.3f' % msg[0], msg[1])



    except RuntimeError as e:
        parsed, err_name, text = decode_exception(e.args)
        if parsed and err_name == 'wamp.error.no_such_procedure':
            print('Failed to contact host master at %s' % master_addr)
            sys.exit(1)
        print('Unexpected error getting master process status:')
        raise
    
    client.stop()

